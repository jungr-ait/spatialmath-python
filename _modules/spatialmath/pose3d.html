<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spatialmath.pose3d &mdash; Spatial Maths package 0.11.0
 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Spatial Maths package
            <img src="../../_static/CartesianSnakes_LogoW.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.9
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spatialmath.html">Class reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../indices.html">Indices</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Spatial Maths package</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>spatialmath.pose3d</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spatialmath.pose3d</h1><div class="highlight"><pre>
<span></span><span class="c1"># Part of Spatial Math Toolbox for Python</span>
<span class="c1"># Copyright (c) 2000 Peter Corke</span>
<span class="c1"># MIT Licence, see details in top-level file: LICENCE</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes to abstract 3D pose and orientation using matrices in SE(3) and SO(3)</span>

<span class="sd">To use::</span>

<span class="sd">    from spatialmath.pose3d import *</span>
<span class="sd">    T = SE3.Rx(0.3)</span>

<span class="sd">    import spatialmath as sm</span>
<span class="sd">    T = sm.SE3.Rx(0.3)</span>


<span class="sd"> .. inheritance-diagram:: spatialmath.pose3d</span>
<span class="sd">    :top-classes: collections.UserList</span>
<span class="sd">    :parts: 1</span>
<span class="sd">    </span>
<span class="sd">.. image:: ../figs/pose-values.png</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=invalid-name</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">from</span> <span class="nn">spatialmath.baseposematrix</span> <span class="kn">import</span> <span class="n">BasePoseMatrix</span>


<span class="c1"># ============================== SO3 =====================================#</span>


<div class="viewcode-block" id="SO3"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3">[docs]</a><span class="k">class</span> <span class="nc">SO3</span><span class="p">(</span><span class="n">BasePoseMatrix</span><span class="p">):</span>  
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SO(3) matrix class</span>

<span class="sd">    This subclass represents rotations in 3D space.  Internally it is a 3x3 </span>
<span class="sd">    orthogonal matrix belonging to the group SO(3).</span>

<span class="sd"> .. inheritance-diagram:: spatialmath.pose3d.SO3</span>
<span class="sd">    :top-classes: collections.UserList</span>
<span class="sd">    :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SO3.__init__"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct new SO(3) object</span>

<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        There are multiple call signatures:</span>

<span class="sd">        - ``SO3()`` is an ``SO3`` instance with one value -- a 3x3 identity</span>
<span class="sd">          matrix which corresponds to a null rotation</span>
<span class="sd">        - ``SO3(R)`` is an ``SO3`` instance with with the value ``R`` which is a</span>
<span class="sd">          3x3 numpy array representing an SO(3) rotation matrix.  If ``check``</span>
<span class="sd">          is ``True`` check the matrix belongs to SO(3).</span>
<span class="sd">        - ``SO3([R1, R2, ... RN])`` is an ``SO3`` instance wwith ``N`` values</span>
<span class="sd">          given by the elements ``Ri`` each of which is a 3x3 NumPy array</span>
<span class="sd">          representing an SO(3) matrix. If ``check`` is ``True`` check the</span>
<span class="sd">          matrix belongs to SO(3).</span>
<span class="sd">        - ``SO3([X1, X2, ... XN])`` is an ``SO3`` instance with ``N`` values</span>
<span class="sd">          given by the elements ``Xi`` each of which is an SO3 or SE3 instance.</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">t2r</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad argument to constructor&#39;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_identity</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># ------------------------------------------------------------------------ #</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the object&#39;s interal matrix representation</span>

<span class="sd">        :return: (3,3)</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        Each value within the ``SO3`` instance is a NumPy array of this shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as rotation matrix</span>

<span class="sd">        :return: rotational component</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(3,3)</span>

<span class="sd">        ``x.R`` is the rotation matrix component of ``x`` as an array with</span>
<span class="sd">        shape (3,3). If ``len(x) &gt; 1``, return an array with shape=(N,3,3).</span>

<span class="sd">        .. warning:: The i&#39;th rotation matrix is ``x[i,:,:]`` or simply </span>
<span class="sd">            ``x[i]``. This is different to the MATLAB version where the i&#39;th</span>
<span class="sd">            rotation matrix is ``x(:,:,i)``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; x.R</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal vector of SO(3) or SE(3)</span>

<span class="sd">        :return: normal vector</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(3,)</span>

<span class="sd">        This is the first column of the rotation submatrix, sometimes called the</span>
<span class="sd">        *normal vector*.  It is parallel to the x-axis of the frame defined by</span>
<span class="sd">        this pose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">o</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Orientation vector of SO(3) or SE(3)</span>

<span class="sd">        :return: orientation vector</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(3,)</span>

<span class="sd">        This is the second column of the rotation submatrix, sometimes called</span>
<span class="sd">        the *orientation vector*.  It is parallel to the y-axis of the frame</span>
<span class="sd">        defined by this pose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approach vector of SO(3) or SE(3)</span>

<span class="sd">        :return: approach vector</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(3,)</span>

<span class="sd">        This is the third column of the rotation submatrix, sometimes called the</span>
<span class="sd">        *approach vector*.  It is parallel to the z-axis of the frame defined by</span>
<span class="sd">        this pose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SO3.inv"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of SO(3)</span>

<span class="sd">        :return: inverse</span>
<span class="sd">        :rtype: SO2 instance</span>

<span class="sd">        Efficiently compute the inverse of each of the SO(3) values taking into</span>
<span class="sd">        account the matrix structure.  For an SO(3) matrix the inverse is the</span>
<span class="sd">        transpose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SO3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SO3</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.eul"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.eul">[docs]</a>    <span class="k">def</span> <span class="nf">eul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as Euler angles</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of Euler angles</span>
<span class="sd">        :rtype: ndarray(3,), ndarray(n,3)</span>

<span class="sd">        ``x.eul`` is the Euler angle representation of the rotation.  Euler angles are</span>
<span class="sd">        a 3-vector :math:`(\phi, \theta, \psi)` which correspond to consecutive</span>
<span class="sd">        rotations about the Z, Y, Z axes respectively.</span>

<span class="sd">        If ``len(x)`` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(3,N)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.Eul`, :func:`~spatialmath.base.transforms3d.tr2eul`</span>
<span class="sd">        :SymPy: not supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">tr2eul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span></div>

<div class="viewcode-block" id="SO3.rpy"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.rpy">[docs]</a>    <span class="k">def</span> <span class="nf">rpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as roll-pitch-yaw angles</span>

<span class="sd">        :param order: angle sequence order, default to &#39;zyx&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: 3-vector of roll-pitch-yaw angles</span>
<span class="sd">        :rtype: ndarray(3,), ndarray(n,3)</span>

<span class="sd">        ``x.rpy`` is the roll-pitch-yaw angle representation of the rotation.  The angles are</span>
<span class="sd">        a 3-vector :math:`(r, p, y)` which correspond to successive rotations about the axes</span>
<span class="sd">        specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        If `len(x)` is:</span>

<span class="sd">        - 1, return an ndarray with shape=(3,)</span>
<span class="sd">        - N&gt;1, return ndarray with shape=(3,N)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.RPY`, :func:`~spatialmath.base.transforms3d.tr2rpy`</span>
<span class="sd">        :SymPy: not supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">tr2rpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span></div>

<div class="viewcode-block" id="SO3.angvec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.angvec">[docs]</a>    <span class="k">def</span> <span class="nf">angvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SO(3) or SE(3) as angle and rotation vector</span>

<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param check: check that rotation matrix is valid</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: :math:`(\theta, {\bf v})`</span>
<span class="sd">        :rtype: float, numpy.ndarray, shape=(3,)</span>

<span class="sd">        ``q.angvec()`` is a tuple :math:`(\theta, v)` containing the rotation </span>
<span class="sd">        angle and a rotation axis which is equivalent to the rotation of</span>
<span class="sd">        the unit quaternion ``q``.</span>

<span class="sd">        By default the angle is in radians but can be changed setting `unit=&#39;deg&#39;`.</span>

<span class="sd">        .. notes::</span>

<span class="sd">            - If the input is SE(3) the translation component is ignored.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; UnitQuaternion.Rz(0.3).angvec()</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternion.AngVec`, :func:`~angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2angvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>

    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SO3.isvalid"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if matrix is valid SO(3)</span>

<span class="sd">        :param x: matrix to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :return: ``True`` if the matrix is a valid element of SO(3), ie. it is a 3x3</span>
<span class="sd">            orthonormal matrix with determinant of +1.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transform3d.isrot`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># ---------------- variant constructors ---------------------------------- #</span>

<div class="viewcode-block" id="SO3.Rx"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Rx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from X-axis rotation</span>

<span class="sd">        :param θ: rotation angle about the X-axis</span>
<span class="sd">        :type θ: float or array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SE3.Rx(θ)`` is an SO(3) rotation of ``θ`` radians about the x-axis</span>
<span class="sd">        - ``SE3.Rx(θ, &quot;deg&quot;)`` as above but ``θ`` is in degrees</span>

<span class="sd">        If ``theta`` is an array then the result is a sequence of rotations defined by consecutive</span>
<span class="sd">        elements.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rx(np.linspace(0, math.pi, 20))</span>
<span class="sd">            &gt;&gt;&gt; len(x)</span>
<span class="sd">            &gt;&gt;&gt; x[7]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">rotx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Ry"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Ry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Ry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from Y-axis rotation</span>

<span class="sd">        :param θ: rotation angle about Y-axis</span>
<span class="sd">        :type θ: float or array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Ry(θ)`` is an SO(3) rotation of ``θ`` radians about the y-axis</span>
<span class="sd">        - ``SO3.Ry(θ, &quot;deg&quot;)`` as above but ``θ`` is in degrees</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined by consecutive</span>
<span class="sd">        elements.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Ry(np.linspace(0, math.pi, 20))</span>
<span class="sd">            &gt;&gt;&gt; len(x)</span>
<span class="sd">            &gt;&gt;&gt; x[7]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">roty</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Rz"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Rz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from Z-axis rotation</span>

<span class="sd">        :param θ: rotation angle about Z-axis</span>
<span class="sd">        :type θ: float or array_like</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Rz(θ)`` is an SO(3) rotation of ``θ`` radians about the z-axis</span>
<span class="sd">        - ``SO3.Rz(θ, &quot;deg&quot;)`` as above but ``θ`` is in degrees</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined by consecutive</span>
<span class="sd">        elements.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; x = SE3.Rz(np.linspace(0, math.pi, 20))</span>
<span class="sd">            &gt;&gt;&gt; len(x)</span>
<span class="sd">            &gt;&gt;&gt; x[7]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">rotz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Rand"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Rand">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rand</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from random rotation</span>

<span class="sd">        :param N: number of random rotations</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :return: SO(3) rotation matrix</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Rand()`` is a random SO(3) rotation.</span>
<span class="sd">        - ``SO3.Rand(N)`` is a sequence of N random rotations.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; x = SO3.Rand()</span>
<span class="sd">            &gt;&gt;&gt; x</span>

<span class="sd">        :seealso: :func:`spatialmath.quaternion.UnitQuaternion.Rand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">q2r</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">rand</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Eul"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Eul">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from Euler angles</span>

<span class="sd">        :param 𝚪: Euler angles</span>
<span class="sd">        :type 𝚪: array_like or numpy.ndarray with shape=(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.Eul(𝚪)`` is an SO(3) rotation defined by a 3-vector of Euler</span>
<span class="sd">          angles :math:`\Gamma = (\phi, \theta, \psi)` which correspond to</span>
<span class="sd">          consecutive rotations about the Z, Y, Z axes respectively. If ``𝚪``</span>
<span class="sd">          is an Nx3 matrix then the result is a sequence of rotations each</span>
<span class="sd">          defined by Euler angles corresponding to the rows of ``angles``.</span>

<span class="sd">        ``SO3.Eul(φ, θ, ψ)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.Eul(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SO3.Eul([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SO3.Eul(10, 20, 30, &#39;deg&#39;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.eul`, :func:`~spatialmath.pose3d.SE3.Eul`, :func:`~spatialmath.base.transforms3d.eul2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">eul2r</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.RPY"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.RPY">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">,</span> <span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from roll-pitch-yaw angles</span>

<span class="sd">        :param angles: roll-pitch-yaw angles</span>
<span class="sd">        :type angles: array_like(3), array_like(n,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param order: rotation order: &#39;zyx&#39; [default], &#39;xyz&#39;, or &#39;yxz&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.RPY(angles)`` is an SO(3) rotation defined by a 3-vector of</span>
<span class="sd">          roll, pitch, yaw angles :math:`(\alpha, \beta, \gamma)`. If ``angles``</span>
<span class="sd">          is an Nx3 matrix then the result is a sequence of rotations each</span>
<span class="sd">          defined by RPY angles corresponding to the rows of angles. The angles</span>
<span class="sd">          correspond to successive rotations about the axes specified by</span>
<span class="sd">          ``order``:</span>

<span class="sd">             - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">               then by roll about the new x-axis.  Convention for a mobile robot with x-axis forward</span>
<span class="sd">               and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. Convention for a camera with z-axis parallel</span>
<span class="sd">              to the optic axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        - ``SO3.RPY(⍺, β, 𝛾)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY(0.1, 0.2, 0.3, order=&#39;xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SO3.RPY(10, 20, 30, &#39;deg&#39;)</span>


<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.rpy`, :func:`~spatialmath.pose3d.SE3.RPY`, :func:`spatialmath.base.transforms3d.rpy2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># angles = base.getmatrix(angles, (None, 3))</span>
        <span class="c1"># return cls(base.rpy2r(angles, order=order, unit=unit), check=False)</span>

        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">rpy2r</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.OA"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.OA">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">OA</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from two vectors</span>

<span class="sd">        :param o: 3-vector parallel to Y- axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :param a: 3-vector parallel to the Z-axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.OA(O, A)`` is an SO(3) rotation defined in terms of</span>
<span class="sd">        vectors parallel to the Y- and Z-axes of its reference frame.  In robotics these axes are</span>
<span class="sd">        respectively called the *orientation* and *approach* vectors defined such that</span>
<span class="sd">        R = [N, O, A] and N = O x A.</span>

<span class="sd">        .. notes::</span>

<span class="sd">            - Only the ``A`` vector is guaranteed to have the same direction in the resulting</span>
<span class="sd">            rotation matrix</span>
<span class="sd">            - ``O`` and ``A`` do not have to be unit-length, they are normalized</span>
<span class="sd">            - ``O`` and ``A` do not have to be orthogonal, so long as they are not parallel</span>

<span class="sd">        :seealso: :func:`spatialmath.base.transforms3d.oa2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">oa2r</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.TwoVectors"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.TwoVectors">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">TwoVectors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) from any two vectors</span>

<span class="sd">        :param x: new x-axis, defaults to None</span>
<span class="sd">        :type x: str, array_like(3), optional</span>
<span class="sd">        :param y: new y-axis, defaults to None</span>
<span class="sd">        :type y: str, array_like(3), optional</span>
<span class="sd">        :param z: new z-axis, defaults to None</span>
<span class="sd">        :type z: str, array_like(3), optional</span>

<span class="sd">        Create a rotation by defining the direction of two of the new</span>
<span class="sd">        axes in terms of the old axes.  Axes are denoted by strings ``&quot;x&quot;``, </span>
<span class="sd">        ``&quot;y&quot;``, ``&quot;z&quot;``, ``&quot;-x&quot;``, ``&quot;-y&quot;``, ``&quot;-z&quot;``.</span>

<span class="sd">        The directions can also be specified by 3-element vectors, but these</span>
<span class="sd">        must be orthogonal.</span>

<span class="sd">        To create a rotation where the new frame has its x-axis in -z-direction</span>
<span class="sd">        of the previous frame, and its z-axis in the x-direction of the previous</span>
<span class="sd">        frame is::</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; SO3.TwoVectors(x=&#39;-z&#39;, z=&#39;x&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">vval</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># skip sign char</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># skip sign char</span>
                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">sign</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">unitvec</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># z = x x y</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># x = y x z</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># y = z x x</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">vval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.AngleAxis"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.AngleAxis">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">AngleAxis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) rotation matrix from rotation angle and axis</span>

<span class="sd">        :param theta: rotation</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.AngleAxis(theta, V)`` is an SO(3) rotation defined by</span>
<span class="sd">        a rotation of ``THETA`` about the vector ``V``.</span>

<span class="sd">        .. note:: :math:`\theta \eq 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">angvec2r</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SO3.AngVec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.AngVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">AngVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) rotation matrix from rotation angle and axis</span>

<span class="sd">        :param theta: rotation</span>
<span class="sd">        :type theta: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.AngVec(theta, V)`` is an SO(3) rotation defined by</span>
<span class="sd">        a rotation of ``THETA`` about the vector ``V``.</span>

<span class="sd">        .. deprecated:: 0.9.8</span>
<span class="sd">            Use :meth:`AngleAxis` instead.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">angvec2r</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.EulerVec"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.EulerVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">EulerVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SO(3) rotation matrix from an Euler rotation vector</span>

<span class="sd">        :param ω: rotation axis</span>
<span class="sd">        :type ω: 3-element array_like</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        ``SO3.EulerVec(ω)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of :math:`\theta = \lVert \omega \rVert` about the</span>
<span class="sd">        unit 3-vector :math:`\omega / \lVert \omega \rVert`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SO3</span>
<span class="sd">            &gt;&gt;&gt; SO3.EulerVec([0.5,0,0])</span>

<span class="sd">        .. note:: :math:`\theta \eq 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;w must be a 3-vector&#39;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">angvec2r</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.Exp"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.Exp">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Exp</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">so3</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SO(3) rotation matrix from so(3)</span>

<span class="sd">        :param S: Lie algebra so(3)</span>
<span class="sd">        :type S: numpy ndarray</span>
<span class="sd">        :param check: check that passed matrix is valid so(3), default True</span>
<span class="sd">        :type check: bool</span>
<span class="sd">        :return: SO(3) rotation</span>
<span class="sd">        :rtype: SO3 instance</span>

<span class="sd">        - ``SO3.Exp(S)`` is an SO(3) rotation defined by its Lie algebra</span>
<span class="sd">          which is a 3x3 so(3) matrix (skew symmetric)</span>
<span class="sd">        - ``SO3.Exp(t)`` is an SO(3) rotation defined by a 3-element twist</span>
<span class="sd">          vector (the unique elements of the so(3) skew-symmetric matrix)</span>
<span class="sd">        - ``SO3.Exp(T)`` is a sequence of SO(3) rotations defined by an Nx3 matrix</span>
<span class="sd">          of twist vectors, one per row.</span>

<span class="sd">        Note:</span>
<span class="sd">        - if :math:`\theta \eq 0` the result in an identity matrix</span>
<span class="sd">        - an input 3x3 matrix is ambiguous, it could be the first or third case above.  In this</span>
<span class="sd">          case the parameter `so3` is the decider.</span>

<span class="sd">        :seealso: :func:`spatialmath.base.transforms3d.trexp`, :func:`spatialmath.base.transformsNd.skew`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">ismatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">so3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SO3.angdist"><a class="viewcode-back" href="../../3d_orient_SO3.html#spatialmath.pose3d.SO3.angdist">[docs]</a>    <span class="k">def</span> <span class="nf">angdist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angular distance metric between rotations</span>

<span class="sd">        :param other: second rotation</span>
<span class="sd">        :type other: SO3 instance</span>
<span class="sd">        :param metric: metric, default is 6</span>
<span class="sd">        :type metric: int</span>
<span class="sd">        :raises TypeError: if other is not an SO3</span>
<span class="sd">        :return: angle in radians</span>
<span class="sd">        :rtype: float or ndarray</span>

<span class="sd">        ``R1.angdist(R2)`` is the geodesic norm, or geodesic distance between two</span>
<span class="sd">        rotations.</span>

<span class="sd">        Several metrics are supported, the first 5 are computed after conversion</span>
<span class="sd">        to unit quaternions.</span>

<span class="sd">        ======   ===============================================================</span>
<span class="sd">        Metric   Details</span>
<span class="sd">        ======   ===============================================================</span>
<span class="sd">        0        :math:`1 - | \q_1 \bullet \q_2 | \in [0, 1]`</span>
<span class="sd">        1        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        2        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        3        :math:`2 \tan^{-1} \| \q_1 - \q_2\| / \|\q_1 + \q_2\| \in [0, \pi/2]`</span>
<span class="sd">        4        :math:`\cos^{-1} \left( 2 (\q_1 \bullet \q_2)^2 - 1\right) \in [0, 1]`</span>
<span class="sd">        5        :math:`\|I - \mat{R}_1 \mat{R}_2^T\| \in [0, 2]`</span>
<span class="sd">        6        :math:`\|\log \mat{R}_1 \mat{R}_2^T\| \in [0, \pi]`</span>
<span class="sd">        ======   ===============================================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; R1 = SO3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; R2 = SO3.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(R1.angdist(R1))</span>
<span class="sd">            &gt;&gt;&gt; print(R1.angdist(R2))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - metrics 1, 2, 4 can throw ValueError &quot;math domain error&quot; due to</span>
<span class="sd">              numeric errors which push the argument of ``acos()`` marginally</span>
<span class="sd">              outside its domain [0, 1].</span>
<span class="sd">            - metrics 2 and 3 are equivalent, but 3 is more robust</span>

<span class="sd">        :seealso: :func:`UnitQuaternion.angdist`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">spatialmath.quaternion</span> <span class="kn">import</span> <span class="n">UnitQuaternion</span>

            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">angdist</span><span class="p">(</span><span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trlog</span><span class="p">(</span><span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown metric&#39;</span><span class="p">)</span>
        
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op2</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ad</span></div></div>

<span class="c1"># ============================== SE3 =====================================#</span>


<div class="viewcode-block" id="SE3"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3">[docs]</a><span class="k">class</span> <span class="nc">SE3</span><span class="p">(</span><span class="n">SO3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SE(3) matrix class</span>

<span class="sd">    This subclass represents rigid-body motion in 3D space.  Internally it is a </span>
<span class="sd">    4x4 homogeneous transformation matrix belonging to the group SE(3).</span>

<span class="sd"> .. inheritance-diagram:: spatialmath.pose3d.SE3</span>
<span class="sd">    :top-classes: collections.UserList</span>
<span class="sd">    :parts: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SE3.__init__"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct new SE(3) object</span>

<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        There are multiple call signatures that return an ``SE3`` instance</span>
<span class="sd">        with one or more values.</span>

<span class="sd">        - ``SE3()`` null motion, value is the identity matrix.</span>
<span class="sd">        - ``SE3(x, y, z)`` is a pure translation of (x,y,z)</span>
<span class="sd">        - ``SE3(T)``  where ``T`` is a 4x4 Numpy  array representing an SE(3)</span>
<span class="sd">          matrix.  If ``check`` is ``True`` check the matrix belongs to SE(3).</span>
<span class="sd">        - ``SE3([T1, T2, ... TN])`` has ``N`` values</span>
<span class="sd">          given by the elements ``Ti`` each of which is a 4x4 NumPy array</span>
<span class="sd">          representing an SE(3) matrix. If ``check`` is ``True`` check the</span>
<span class="sd">          matrix belongs to SE(3).</span>
<span class="sd">        - ``SE3(X)`` where ``X`` is:</span>
<span class="sd">          -  ``SE3`` is a copy of ``X``</span>
<span class="sd">          -  ``SO3`` is the rotation of ``X`` with zero translation</span>
<span class="sd">          -  ``SE2`` is the z-axis rotation and x- and y-axis translation of</span>
<span class="sd">             ``X``</span>
<span class="sd">        - ``SE3([X1, X2, ... XN])`` has ``N`` values</span>
<span class="sd">          given by the elements ``Xi`` each of which is an SE3 instance.</span>
<span class="sd">        </span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># just one argument passed</span>

            <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">arghandler</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">SO3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">r2t</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;SE2&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="c1"># convert SE(2) to SE(3)</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">out</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">out</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="c1"># SE3( [x, y, z] )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># SE3( Nx3 )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bad argument to constructor&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># SE3(x, y, z)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_identity</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        
    <span class="c1"># ------------------------------------------------------------------------ #</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the object&#39;s internal matrix representation</span>

<span class="sd">        :return: (4,4)</span>
<span class="sd">        :rtype: tuple</span>

<span class="sd">        Each value within the ``SE3`` instance is a NumPy array of this shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translational component of SE(3)</span>

<span class="sd">        :return: translational component of SE(3)</span>
<span class="sd">        :rtype: numpy.ndarray</span>

<span class="sd">        ``x.t`` is the translational component of ``x`` as an array with</span>
<span class="sd">        shape (3,). If ``len(x) &gt; 1``, return an array with shape=(N,3).</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>

<span class="sd">            &gt;&gt;&gt; x = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; x.t</span>
<span class="sd">            array([1., 2., 3.])</span>
<span class="sd">            &gt;&gt;&gt; x = SE3([ SE3(1,2,3), SE3(4,5,6)])</span>
<span class="sd">            &gt;&gt;&gt; x.t</span>
<span class="sd">            array([[1., 2., 3.],</span>
<span class="sd">                   [4., 5., 6.]])</span>

<span class="sd">        </span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>

    <span class="nd">@t</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only assign translation to length 1 object&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SE3.inv"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.inv">[docs]</a>    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of SE(3)</span>

<span class="sd">        :return: inverse</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        Efficiently compute the inverse of each of the SE(3) values taking into</span>
<span class="sd">        account the matrix structure.</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            T = \left[ \begin{array}{cc} \mat{R} &amp; \vec{t} \\ 0 &amp; 1 \end{array} \right],</span>
<span class="sd">            \mat{T}^{-1} = \left[ \begin{array}{cc} \mat{R}^T &amp; -\mat{R}^T \vec{t} \\ 0 &amp; 1 \end{array} \right]`</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; x = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; x.inv()</span>
<span class="sd">            SE3(array([[ 1.,  0.,  0., -1.],</span>
<span class="sd">                       [ 0.,  1.,  0., -2.],</span>
<span class="sd">                       [ 0.,  0.,  1., -3.],</span>
<span class="sd">                       [ 0.,  0.,  0.,  1.]]))</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trinv`</span>

<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SE3</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SE3</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">trinv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.delta"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.delta">[docs]</a>    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X2</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infinitesimal difference of SE(3) values</span>

<span class="sd">        :return: differential motion vector</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(6,)</span>

<span class="sd">        ``X1.delta(X2)`` is the differential motion (6x1) corresponding to</span>
<span class="sd">        infinitesimal motion (in the ``X1`` frame) from pose ``X1`` to ``X2``.</span>

<span class="sd">        The vector :math:`d = [\delta_x, \delta_y, \delta_z, \theta_x, \theta_y, \theta_z]`</span>
<span class="sd">        represents infinitesimal translation and rotation.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; x1 = SE3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; x2 = SE3.Rx(0.3001)</span>
<span class="sd">            &gt;&gt;&gt; x1.delta(x2)</span>
<span class="sd">            array([0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 9.99999998e-05,</span>
<span class="sd">                0.00000000e+00, 0.00000000e+00])</span>

<span class="sd">        .. note::</span>

<span class="sd">            - the displacement is only an approximation to the motion, and assumes</span>
<span class="sd">              that ``X1`` ~ ``X2``.</span>
<span class="sd">            - can be considered as an approximation to the effect of spatial velocity over a</span>
<span class="sd">              a time interval, ie. the average spatial velocity multiplied by time.</span>

<span class="sd">        :Reference: Robotics, Vision &amp; Control: Second Edition, P. Corke, Springer 2016; p67.</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.tr2delta`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">X2</span><span class="o">.</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Ad"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Ad">[docs]</a>    <span class="k">def</span> <span class="nf">Ad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjoint of SE(3)</span>

<span class="sd">        :return: adjoint matrix</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(6,6)</span>

<span class="sd">        ``SE3.Ad`` is the 6x6 adjoint matrix</span>

<span class="sd">        If spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        and the SE(3) represents the pose of {B} relative to {A}, </span>
<span class="sd">        ie. :math:`{}^A {\bf T}_B, and the adjoint is :math:`\mathbf{A}` then</span>
<span class="sd">        :math:`{}^{A}\!\nu = \mathbf{A} {}^{B}\!\nu`.</span>

<span class="sd">        .. warning:: Do not use this method to map velocities </span>
<span class="sd">            between robot base and end-effector frames - use ``jacob()``.</span>

<span class="sd">        .. note:: Use this method to map velocities between two frames on</span>
<span class="sd">            the same rigid-body.  </span>

<span class="sd">        :reference: Robotics, Vision &amp; Control: Second Edition, P. Corke, Springer 2016; p65.</span>
<span class="sd">        :seealso: SE3.jacob, Twist.ad, :func:`~spatialmath.base.tr2jac`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2adjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.jacob"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.jacob">[docs]</a>    <span class="k">def</span> <span class="nf">jacob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Velocity transform for SE(3)</span>

<span class="sd">        :return: Jacobian matrix</span>
<span class="sd">        :rtype: numpy.ndarray, shape=(6,6)</span>

<span class="sd">        ``SE3.jacob()`` is the 6x6 Jacobian that maps spatial velocity or</span>
<span class="sd">        differential motion from frame {B} to frame {A} where the pose of {B}</span>
<span class="sd">        relative to {A} is represented by the homogeneous transform T =</span>
<span class="sd">        :math:`{}^A {\bf T}_B`.  </span>
<span class="sd">        </span>
<span class="sd">        .. note::</span>
<span class="sd">            - To map from frame {A} to frame {B} use the transpose of this matrix.</span>
<span class="sd">            - Use this method to map velocities between the robot end-effector frame</span>
<span class="sd">              and the base frames.</span>

<span class="sd">        .. warning:: Do not use this method to map velocities between two frames</span>
<span class="sd">            on the same rigid-body.</span>

<span class="sd">        :seealso: SE3.Ad, Twist.ad, :func:`~spatialmath.base.tr2jac`</span>
<span class="sd">        :Reference: Robotics, Vision &amp; Control: Second Edition, P. Corke, Springer 2016; p65.</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">tr2jac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.twist"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.twist">[docs]</a>    <span class="k">def</span> <span class="nf">twist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SE(3) as twist</span>

<span class="sd">        :return: equivalent rigid-body motion as a twist vector</span>
<span class="sd">        :rtype: Twist3 instance</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; x = SE3(1,2,3)</span>
<span class="sd">            &gt;&gt;&gt; x.twist()</span>
<span class="sd">            Twist3([1, 2, 3, 0, 0, 0])</span>

<span class="sd">        :seealso: :func:`spatialmath.twist.Twist3`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">spatialmath.twist</span> <span class="kn">import</span> <span class="n">Twist3</span>

        <span class="k">return</span> <span class="n">Twist3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>
    <span class="c1"># ------------------------------------------------------------------------ #</span>

<div class="viewcode-block" id="SE3.isvalid"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.isvalid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">isvalid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if matrix is a valid SE(3)</span>

<span class="sd">        :param x: matrix to test</span>
<span class="sd">        :type x: numpy.ndarray</span>
<span class="sd">        :return: ``True`` if the matrix is 4x4 and a valid element of SE(3), ie. it</span>
<span class="sd">                 is a valid homogeneous transformation matrix.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.ishom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">ishom</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">)</span></div>

    <span class="c1"># ---------------- variant constructors ---------------------------------- #</span>

<div class="viewcode-block" id="SE3.Rx"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create anSE(3) pure rotation about the X-axis</span>

<span class="sd">        :param θ: rotation angle about X-axis</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param t: translation, optional</span>
<span class="sd">        :type t: 3-element array-like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Rx(θ)`` is an SE(3) rotation of θ radians about the x-axis</span>
<span class="sd">        - ``SE3.Rx(θ, &quot;deg&quot;)`` as above but θ is in degrees</span>
<span class="sd">        - ``SE3.Rx(θ, t=T)`` as above but also sets the translational component</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined</span>
<span class="sd">        by consecutive elements.</span>

<span class="sd">        .. note:: The translation option only works for the scalar θ case.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; SE3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rx([0.3, 0.4])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trotx`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">trotx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Ry"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Ry">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Ry</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation about the Y-axis</span>

<span class="sd">        :param θ: rotation angle about X-axis</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param t: translation, optional</span>
<span class="sd">        :type t: 3-element array-like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Ry(θ)`` is an SO(3) rotation of θ radians about the y-axis</span>
<span class="sd">        - ``SE3.Ry(θ, &quot;deg&quot;)`` as above but θ is in degrees</span>
<span class="sd">        - ``SE3.Ry(θ, t=T)`` as above but also sets the translational component</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined</span>
<span class="sd">        by consecutive elements.</span>

<span class="sd">        .. note:: The translation option only works for the scalar θ case.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; SE3.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Ry([0.3, 0.4])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.troty`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">troty</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Rz"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation about the Z-axis</span>

<span class="sd">        :param θ: rotation angle about Z-axis</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param t: translation, optional</span>
<span class="sd">        :type t: 3-element array-like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Rz(θ)`` is an SO(3) rotation of θ radians about the z-axis</span>
<span class="sd">        - ``SE3.Rz(θ, &quot;deg&quot;)`` as above but θ is in degrees</span>
<span class="sd">        - ``SE3.Rz(θ, t=T)`` as above but also sets the translational component</span>

<span class="sd">        If ``θ`` is an array then the result is a sequence of rotations defined</span>
<span class="sd">        by consecutive elements.</span>

<span class="sd">        .. note:: The translation option only works for the scalar θ case.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; SE3.Rz(0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Rz([0.3, 0.4])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trotz`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">trotz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Rand"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rand">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rand</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xrange</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">yrange</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">zrange</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a random SE(3)</span>

<span class="sd">        :param xrange: x-axis range [min,max], defaults to [-1, 1]</span>
<span class="sd">        :type xrange: 2-element sequence, optional</span>
<span class="sd">        :param yrange: y-axis range [min,max], defaults to [-1, 1]</span>
<span class="sd">        :type yrange: 2-element sequence, optional</span>
<span class="sd">        :param zrange: z-axis range [min,max], defaults to [-1, 1]</span>
<span class="sd">        :type zrange: 2-element sequence, optional</span>
<span class="sd">        :param N: number of random transforms</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        Return an SE3 instance with random rotation and translation.</span>

<span class="sd">        - ``SE3.Rand()`` is a random SE(3) translation.</span>
<span class="sd">        - ``SE3.Rand(N)`` is an SE3 object containing a sequence of N random</span>
<span class="sd">          poses.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; SE3.Rand(2)</span>
<span class="sd">            SE3([</span>
<span class="sd">            array([[ 0.58076657,  0.64578702, -0.49565041, -0.78585825],</span>
<span class="sd">                [-0.57373134, -0.10724881, -0.8119914 ,  0.72069253],</span>
<span class="sd">                [-0.57753142,  0.75594763,  0.30822173,  0.12291999],</span>
<span class="sd">                [ 0.        ,  0.        ,  0.        ,  1.        ]]),</span>
<span class="sd">            array([[ 0.96481299, -0.26267256, -0.01179066,  0.80294729],</span>
<span class="sd">                [ 0.06421463,  0.19190584,  0.97931028, -0.15021311],</span>
<span class="sd">                [-0.25497525, -0.94560841,  0.20202067,  0.02684599],</span>
<span class="sd">                [ 0.        ,  0.        ,  0.        ,  1.        ]]) ])</span>

<span class="sd">        :seealso: :func:`~spatialmath.quaternions.UnitQuaternion.Rand`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># random values in the range</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">yrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">yrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># random values in the range</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">yrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">zrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># random values in the range</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">SO3</span><span class="o">.</span><span class="n">Rand</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">@</span> <span class="n">base</span><span class="o">.</span><span class="n">r2t</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">R</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Eul"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Eul">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Eul</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation from Euler angles</span>

<span class="sd">        :param 𝚪: Euler angles</span>
<span class="sd">        :type 𝚪: array_like or numpy.ndarray with shape=(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Eul(𝚪)`` is an SE(3) rotation defined by a 3-vector of Euler</span>
<span class="sd">          angles :math:`\Gamma=(\phi, \theta, \psi)` which correspond to</span>
<span class="sd">          consecutive rotations about the Z, Y, Z axes respectively.</span>

<span class="sd">        If ``𝚪`` is an Nx3 matrix then the result is a sequence of</span>
<span class="sd">        rotations each defined by Euler angles corresponding to the rows of</span>
<span class="sd">        ``𝚪``.</span>

<span class="sd">        - ``SE3.Eul(φ, θ, ψ)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.Eul(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Eul([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SE3.Eul(10, 20, 30, unit=&#39;deg&#39;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.eul`, :func:`~spatialmath.base.transforms3d.eul2r`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">eul2tr</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">eul2tr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.RPY"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.RPY">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">RPY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;zyx&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation from roll-pitch-yaw angles</span>

<span class="sd">        :param 𝚪: roll-pitch-yaw angles</span>
<span class="sd">        :type 𝚪: array_like or numpy.ndarray with shape=(N,3)</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param order: rotation order: &#39;zyx&#39; [default], &#39;xyz&#39;, or &#39;yxz&#39;</span>
<span class="sd">        :type order: str</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.RPY(𝚪)`` is an SE(3) rotation defined by a 3-vector of roll,</span>
<span class="sd">          pitch, yaw angles :math:`\Gamma=(r, p, y)` which correspond to</span>
<span class="sd">          successive rotations about the axes specified by ``order``:</span>

<span class="sd">            - ``&#39;zyx&#39;`` [default], rotate by yaw about the z-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new x-axis.  This is the **convention** for a mobile robot with x-axis forward</span>
<span class="sd">              and y-axis sideways.</span>
<span class="sd">            - ``&#39;xyz&#39;``, rotate by yaw about the x-axis, then by pitch about the new y-axis,</span>
<span class="sd">              then by roll about the new z-axis. This is the **convention** for a robot gripper with z-axis forward</span>
<span class="sd">              and y-axis between the gripper fingers.</span>
<span class="sd">            - ``&#39;yxz&#39;``, rotate by yaw about the y-axis, then by pitch about the new x-axis,</span>
<span class="sd">              then by roll about the new z-axis. This is the **convention** for a camera with z-axis parallel</span>
<span class="sd">              to the optical axis and x-axis parallel to the pixel rows.</span>

<span class="sd">        If ``𝚪`` is an Nx3 matrix then the result is a sequence of rotations each defined by RPY angles</span>
<span class="sd">        corresponding to the rows of ``𝚪``.</span>

<span class="sd">        - ``SE3.RPY(⍺, β, 𝛾)`` as above but the angles are provided as three</span>
<span class="sd">          scalars.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY(0.1, 0.2, 0.3)</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY([0.1, 0.2, 0.3])</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY(0.1, 0.2, 0.3, order=&#39;xyz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; SE3.RPY(10, 20, 30, unit=&#39;deg&#39;)</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.rpy`, :func:`~spatialmath.base.transforms3d.rpy2r`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">rpy2tr</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">rpy2tr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.OA"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.OA">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">OA</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation from two vectors</span>

<span class="sd">        :param o: 3-vector parallel to Y- axis</span>
<span class="sd">        :type o: array_like</span>
<span class="sd">        :param a: 3-vector parallel to the Z-axis</span>
<span class="sd">        :type a: array_like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.OA(o, a)`` is an SE(3) rotation defined in terms of vectors ``o``</span>
<span class="sd">        and ``a`` respectively parallel to the Y- and Z-axes of its reference</span>
<span class="sd">        frame.  In robotics these axes are respectively called the *orientation*</span>
<span class="sd">        and *approach* vectors defined such that :math:`\mathbf{R} = [n, o, a]`</span>
<span class="sd">        and :math:`n = o \times a`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The ``a`` vector is the only guaranteed to have the same direction in the resulting</span>
<span class="sd">              rotation matrix</span>
<span class="sd">            - ``o`` and ``a`` do not have to be unit-length, they are normalized</span>
<span class="sd">            - ``o`` and ``a`` do not have to be orthogonal, so long as they are not parallel</span>
<span class="sd">              ``o`` is adjusted to be orthogonal to ``a``.</span>

<span class="sd">        Example::</span>

<span class="sd">            &gt;&gt;&gt; SE3.OA([1, 0, 0], [0, 0, -1])</span>
<span class="sd">            SE3(array([[-0.,  1.,  0.,  0.],</span>
<span class="sd">                    [ 1.,  0.,  0.,  0.],</span>
<span class="sd">                    [ 0.,  0., -1.,  0.],</span>
<span class="sd">                    [ 0.,  0.,  0.,  1.]]))</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.oa2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">oa2tr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.AngleAxis"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.AngleAxis">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">AngleAxis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation matrix from rotation angle and axis</span>

<span class="sd">        :param θ: rotation</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.AngleAxis(θ, v)`` is an SE(3) rotation defined by</span>
<span class="sd">        a rotation of ``θ`` about the vector ``v``.</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \mbox{if}\,\, \theta \left\{ \begin{array}{ll}</span>
<span class="sd">                = 0 &amp; \mbox{return identity matrix}\\</span>
<span class="sd">                \ne 0 &amp; \mbox{v must have a finite length}</span>
<span class="sd">                \end{array}</span>
<span class="sd">                \right.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.pose3d.SE3.EulerVec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">angvec2tr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.AngVec"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.AngVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">AngVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) pure rotation matrix from rotation angle and axis</span>

<span class="sd">        :param θ: rotation</span>
<span class="sd">        :type θ: float</span>
<span class="sd">        :param unit: angular units: &#39;rad&#39; [default], or &#39;deg&#39;</span>
<span class="sd">        :type unit: str</span>
<span class="sd">        :param v: rotation axis, 3-vector</span>
<span class="sd">        :type v: array_like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.AngVec(θ, v)`` is an SE(3) rotation defined by</span>
<span class="sd">        a rotation of ``θ`` about the vector ``v``.</span>

<span class="sd">        .. deprecated:: 0.9.8</span>
<span class="sd">            Use :meth:`AngleAxis` instead.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.angvec`, :func:`~spatialmath.pose3d.SE3.EulerVec`, :func:`~spatialmath.base.transforms3d.angvec2r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">angvec2tr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.EulerVec"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.EulerVec">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">EulerVec</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new SE(3) pure rotation matrix from an Euler rotation vector</span>

<span class="sd">        :param ω: rotation axis</span>
<span class="sd">        :type ω: 3-element array_like</span>
<span class="sd">        :return: SE(3) rotation</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        ``SE3.EulerVec(ω)`` is a unit quaternion that describes the 3D rotation</span>
<span class="sd">        defined by a rotation of :math:`\theta = \lVert \omega \rVert` about the</span>
<span class="sd">        unit 3-vector :math:`\omega / \lVert \omega \rVert`.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        </span>
<span class="sd">            &gt;&gt;&gt; from spatialmath import SE3</span>
<span class="sd">            &gt;&gt;&gt; SE3.EulerVec([0.5,0,0])</span>

<span class="sd">        .. note:: :math:`\theta = 0` the result in an identity matrix, otherwise</span>
<span class="sd">            ``V`` must have a finite length, ie. :math:`|V| &gt; 0`.</span>

<span class="sd">        :seealso: :func:`~spatialmath.pose3d.SE3.AngVec`, :func:`~spatialmath.base.transforms3d.angvec2tr`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;w must be a 3-vector&#39;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">angvec2tr</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Exp"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Exp">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Exp</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) matrix from se(3)</span>

<span class="sd">        :param S: Lie algebra se(3) matrix</span>
<span class="sd">        :type S: numpy ndarray</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        - ``SE3.Exp(S)`` is an SE(3) rotation defined by its Lie algebra</span>
<span class="sd">          which is a 4x4 se(3) matrix (skew symmetric)</span>
<span class="sd">        - ``SE3.Exp(t)`` is an SE(3) rotation defined by a 6-element twist</span>
<span class="sd">          vector (the unique elements of the se(3) skew-symmetric matrix)</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.trexp`, :func:`~spatialmath.base.transformsNd.skew`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">isvector</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">S</span><span class="p">)),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trexp</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
            

<div class="viewcode-block" id="SE3.Delta"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Delta">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Delta</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create SE(3) from differential motion</span>

<span class="sd">        :param d: differential motion</span>
<span class="sd">        :type d: 6-element array_like</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>


<span class="sd">        ``T = delta2tr(d)`` is an SE(3) representing differential </span>
<span class="sd">        motion :math:`d = [\delta_x, \delta_y, \delta_z, \theta_x, \theta_y, \theta_z]`.</span>

<span class="sd">        :Reference: Robotics, Vision &amp; Control: Second Edition, P. Corke, Springer 2016; p67.</span>

<span class="sd">        :seealso: :func:`~delta`, :func:`~spatialmath.base.transform3d.delta2tr`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trnorm</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">delta2tr</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SE3.Tx"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Tx">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Tx</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) translation along the X-axis</span>

<span class="sd">        :param x: translation distance along the X-axis</span>
<span class="sd">        :type x: float</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        `SE3.Tx(x)` is an SE(3) translation of ``x`` along the x-axis</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; SE3.Tx(2)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Tx([2,3])</span>


<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.transl`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="SE3.Ty"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Ty">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Ty</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) translation along the Y-axis</span>

<span class="sd">        :param y: translation distance along the Y-axis</span>
<span class="sd">        :type y: float</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        `SE3.Ty(y) is an SE(3) translation of ``y`` along the y-axis</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; SE3.Ty(2)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Ty([2,3])</span>


<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.transl`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_y</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">y</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Tz"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Tz">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Tz</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) translation along the Z-axis</span>

<span class="sd">        :param z: translation distance along the Z-axis</span>
<span class="sd">        :type z: float</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>

<span class="sd">        `SE3.Tz(z)` is an SE(3) translation of ``z`` along the z-axis</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; SE3.Tz(2)</span>
<span class="sd">            &gt;&gt;&gt; SE3.Tz([2,3])</span>

<span class="sd">        :seealso: :func:`~spatialmath.base.transforms3d.transl`</span>
<span class="sd">        :SymPy: supported</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">base</span><span class="o">.</span><span class="n">transl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_z</span><span class="p">)</span> <span class="k">for</span> <span class="n">_z</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">z</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SE3.Rt"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.Rt">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Rt</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an SE(3) from rotation and translation</span>

<span class="sd">        :param R: rotation</span>
<span class="sd">        :type R: SO3 or ndarray(3,3)</span>
<span class="sd">        :param t: translation</span>
<span class="sd">        :type t: array_like(3)</span>
<span class="sd">        :param check: check rotation validity, defaults to True</span>
<span class="sd">        :type check: bool, optional</span>
<span class="sd">        :raises ValueError: bad rotation matrix</span>
<span class="sd">        :return: SE(3) matrix</span>
<span class="sd">        :rtype: SE3 instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">SO3</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">A</span>
        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">isrot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="n">check</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expecting SO3 or rotation matrix&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">rt2tr</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span></div>

<div class="viewcode-block" id="SE3.angdist"><a class="viewcode-back" href="../../3d_pose_SE3.html#spatialmath.pose3d.SE3.angdist">[docs]</a>    <span class="k">def</span> <span class="nf">angdist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Angular distance metric between poses</span>

<span class="sd">        :param other: second rotation</span>
<span class="sd">        :type other: SE3 instance</span>
<span class="sd">        :param metric: metric, default is 6</span>
<span class="sd">        :type metric: int</span>
<span class="sd">        :raises TypeError: if other is not an SE3</span>
<span class="sd">        :return: angle in radians</span>
<span class="sd">        :rtype: float or ndarray</span>

<span class="sd">        ``T1.angdist(T2)`` is the geodesic norm, or geodesic distance between the</span>
<span class="sd">        rotational parts of the two poses.</span>

<span class="sd">        Several metrics are supported, the first 5 are computed after conversion</span>
<span class="sd">        to unit quaternions.</span>

<span class="sd">        ======   ===============================================================</span>
<span class="sd">        Metric   Details</span>
<span class="sd">        ======   ===============================================================</span>
<span class="sd">        0        :math:`1 - | \q_1 \bullet \q_2 | \in [0, 1]`</span>
<span class="sd">        1        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        2        :math:`\cos^{-1} | \q_1 \bullet \q_2 | \in [0, \pi/2]`</span>
<span class="sd">        3        :math:`2 \tan^{-1} \| \q_1 - \q_2\| / \|\q_1 + \q_2\| \in [0, \pi/2]`</span>
<span class="sd">        4        :math:`\cos^{-1} \left( 2 (\q_1 \bullet \q_2)^2 - 1\right) \in [0, 1]`</span>
<span class="sd">        5        :math:`\|I - \mat{R}_1 \mat{R}_2^T\| \in [0, 2]`</span>
<span class="sd">        6        :math:`\|\log \mat{R}_1 \mat{R}_2^T\| \in [0, \pi]`</span>
<span class="sd">        ======   ===============================================================</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from spatialmath import UnitQuaternion</span>
<span class="sd">            &gt;&gt;&gt; T1 = SE3.Rx(0.3)</span>
<span class="sd">            &gt;&gt;&gt; T2 = SE3.Ry(0.3)</span>
<span class="sd">            &gt;&gt;&gt; print(T1.angdist(T1))</span>
<span class="sd">            &gt;&gt;&gt; print(T1.angdist(T2))</span>

<span class="sd">        .. note::</span>
<span class="sd">            - metrics 1, 2, 4 can throw ValueError &quot;math domain error&quot; due to</span>
<span class="sd">              numeric errors which push the argument of ``acos()`` marginally</span>
<span class="sd">              outside its domain [0, 1].</span>
<span class="sd">            - metrics 2 and 3 are equivalent, but 3 is more robust</span>

<span class="sd">        :seealso: :func:`UnitQuaternion.angdist`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">spatialmath.quaternion</span> <span class="kn">import</span> <span class="n">UnitQuaternion</span>

            <span class="k">return</span> <span class="n">UnitQuaternion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">angdist</span><span class="p">(</span><span class="n">UnitQuaternion</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">T1</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">T2</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">trlog</span><span class="p">(</span><span class="n">T1</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">@</span> <span class="n">T2</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">twist</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown metric&#39;</span><span class="p">)</span>
        
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op2</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ad</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ad</span></div></div>

    <span class="c1"># @classmethod</span>
    <span class="c1"># def SO3(cls, R, t=None, check=True):</span>
    <span class="c1">#     if isinstance(R, SO3):</span>
    <span class="c1">#         R = R.A</span>
    <span class="c1">#     elif base.isrot(R, check=check):</span>
    <span class="c1">#         pass</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         raise ValueError(&#39;expecting SO3 or rotation matrix&#39;)</span>
    <span class="c1">#     if t is None:</span>
    <span class="c1">#         return cls(base.r2t(R))</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return cls(base.rt2tr(R, t))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>   <span class="c1"># pragma: no cover</span>

    <span class="kn">import</span> <span class="nn">pathlib</span>
    <span class="n">exec</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;tests&quot;</span> <span class="o">/</span> <span class="s2">&quot;test_pose3d.py&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>  <span class="c1"># pylint: disable=exec-used</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Peter Corke.
      <span class="lastupdated">Last updated on 22-Nov-2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>